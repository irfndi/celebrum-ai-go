
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>database: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/irfndi/celebrum-ai-go/internal/database/blacklist_repository.go (82.5%)</option>
				
				<option value="file1">github.com/irfndi/celebrum-ai-go/internal/database/postgres.go (71.4%)</option>
				
				<option value="file2">github.com/irfndi/celebrum-ai-go/internal/database/redis.go (59.5%)</option>
				
				<option value="file3">github.com/irfndi/celebrum-ai-go/internal/database/telemetry.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package database

import (
        "context"
        "database/sql"
        "fmt"
        "time"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
)

// ExchangeBlacklistEntry represents a blacklisted exchange in the database
type ExchangeBlacklistEntry struct {
        ID           int64      `json:"id" db:"id"`
        ExchangeName string     `json:"exchange_name" db:"exchange_name"`
        Reason       string     `json:"reason" db:"reason"`
        CreatedAt    time.Time  `json:"created_at" db:"created_at"`
        UpdatedAt    time.Time  `json:"updated_at" db:"updated_at"`
        ExpiresAt    *time.Time `json:"expires_at,omitempty" db:"expires_at"`
        IsActive     bool       `json:"is_active" db:"is_active"`
}

// DatabasePool defines the interface for database pool operations
// This interface allows for both real pool and mock pool implementations
type DatabasePool interface {
        QueryRow(ctx context.Context, sql string, args ...interface{}) pgx.Row
        Exec(ctx context.Context, sql string, args ...interface{}) (pgconn.CommandTag, error)
        Query(ctx context.Context, sql string, args ...interface{}) (pgx.Rows, error)
}

// BlacklistRepository handles database operations for exchange blacklist
type BlacklistRepository struct {
        pool DatabasePool
}

// NewBlacklistRepository creates a new blacklist repository
func NewBlacklistRepository(pool DatabasePool) *BlacklistRepository <span class="cov8" title="1">{
        return &amp;BlacklistRepository{
                pool: pool,
        }
}</span>

// AddExchange adds an exchange to the blacklist
func (r *BlacklistRepository) AddExchange(ctx context.Context, exchangeName, reason string, expiresAt *time.Time) (*ExchangeBlacklistEntry, error) <span class="cov8" title="1">{
        query := `
                INSERT INTO exchange_blacklist (exchange_name, reason, expires_at, is_active)
                VALUES ($1, $2, $3, true)
                ON CONFLICT (exchange_name) WHERE is_active = true
                DO UPDATE SET 
                        reason = EXCLUDED.reason,
                        expires_at = EXCLUDED.expires_at,
                        updated_at = CURRENT_TIMESTAMP
                RETURNING id, exchange_name, reason, created_at, updated_at, expires_at, is_active
        `

        var entry ExchangeBlacklistEntry
        err := r.pool.QueryRow(ctx, query, exchangeName, reason, expiresAt).Scan(
                &amp;entry.ID,
                &amp;entry.ExchangeName,
                &amp;entry.Reason,
                &amp;entry.CreatedAt,
                &amp;entry.UpdatedAt,
                &amp;entry.ExpiresAt,
                &amp;entry.IsActive,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to add exchange to blacklist: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;entry, nil</span>
}

// RemoveExchange removes an exchange from the blacklist
func (r *BlacklistRepository) RemoveExchange(ctx context.Context, exchangeName string) error <span class="cov8" title="1">{
        query := `
                UPDATE exchange_blacklist 
                SET is_active = false, updated_at = CURRENT_TIMESTAMP
                WHERE exchange_name = $1 AND is_active = true
        `

        result, err := r.pool.Exec(ctx, query, exchangeName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove exchange from blacklist: %w", err)
        }</span>

        <span class="cov8" title="1">if result.RowsAffected() == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("exchange %s not found in blacklist or already inactive", exchangeName)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// IsBlacklisted checks if an exchange is currently blacklisted
func (r *BlacklistRepository) IsBlacklisted(ctx context.Context, exchangeName string) (bool, string, error) <span class="cov8" title="1">{
        query := `
                SELECT reason, expires_at
                FROM exchange_blacklist 
                WHERE exchange_name = $1 AND is_active = true
                AND (expires_at IS NULL OR expires_at &gt; CURRENT_TIMESTAMP)
        `

        var reason string
        var expiresAt *time.Time
        err := r.pool.QueryRow(ctx, query, exchangeName).Scan(&amp;reason, &amp;expiresAt)
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return false, "", nil
                }</span>
                <span class="cov0" title="0">return false, "", fmt.Errorf("failed to check blacklist status: %w", err)</span>
        }

        <span class="cov8" title="1">return true, reason, nil</span>
}

// GetAllBlacklisted returns all currently blacklisted exchanges
func (r *BlacklistRepository) GetAllBlacklisted(ctx context.Context) ([]ExchangeBlacklistEntry, error) <span class="cov8" title="1">{
        query := `
                SELECT id, exchange_name, reason, created_at, updated_at, expires_at, is_active
                FROM exchange_blacklist 
                WHERE is_active = true
                AND (expires_at IS NULL OR expires_at &gt; CURRENT_TIMESTAMP)
                ORDER BY created_at DESC
        `

        rows, err := r.pool.Query(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get blacklisted exchanges: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var entries []ExchangeBlacklistEntry
        for rows.Next() </span><span class="cov8" title="1">{
                var entry ExchangeBlacklistEntry
                err := rows.Scan(
                        &amp;entry.ID,
                        &amp;entry.ExchangeName,
                        &amp;entry.Reason,
                        &amp;entry.CreatedAt,
                        &amp;entry.UpdatedAt,
                        &amp;entry.ExpiresAt,
                        &amp;entry.IsActive,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan blacklist entry: %w", err)
                }</span>
                <span class="cov8" title="1">entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating blacklist entries: %w", err)
        }</span>

        <span class="cov8" title="1">return entries, nil</span>
}

// CleanupExpired removes expired blacklist entries
func (r *BlacklistRepository) CleanupExpired(ctx context.Context) (int64, error) <span class="cov8" title="1">{
        query := `
                UPDATE exchange_blacklist 
                SET is_active = false, updated_at = CURRENT_TIMESTAMP
                WHERE is_active = true 
                AND expires_at IS NOT NULL 
                AND expires_at &lt;= CURRENT_TIMESTAMP
        `

        result, err := r.pool.Exec(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to cleanup expired blacklist entries: %w", err)
        }</span>

        <span class="cov8" title="1">return result.RowsAffected(), nil</span>
}

// GetBlacklistHistory returns the history of blacklist changes
func (r *BlacklistRepository) GetBlacklistHistory(ctx context.Context, limit int) ([]ExchangeBlacklistEntry, error) <span class="cov8" title="1">{
        query := `
                SELECT id, exchange_name, reason, created_at, updated_at, expires_at, is_active
                FROM exchange_blacklist 
                ORDER BY updated_at DESC
                LIMIT $1
        `

        rows, err := r.pool.Query(ctx, query, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get blacklist history: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var entries []ExchangeBlacklistEntry
        for rows.Next() </span><span class="cov8" title="1">{
                var entry ExchangeBlacklistEntry
                err := rows.Scan(
                        &amp;entry.ID,
                        &amp;entry.ExchangeName,
                        &amp;entry.Reason,
                        &amp;entry.CreatedAt,
                        &amp;entry.UpdatedAt,
                        &amp;entry.ExpiresAt,
                        &amp;entry.IsActive,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan blacklist history entry: %w", err)
                }</span>
                <span class="cov8" title="1">entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating blacklist history: %w", err)
        }</span>

        <span class="cov8" title="1">return entries, nil</span>
}

// ClearAll deactivates all blacklist entries
func (r *BlacklistRepository) ClearAll(ctx context.Context) (int64, error) <span class="cov8" title="1">{
        query := `
                UPDATE exchange_blacklist 
                SET is_active = false, updated_at = CURRENT_TIMESTAMP
                WHERE is_active = true
        `

        result, err := r.pool.Exec(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to clear all blacklist entries: %w", err)
        }</span>

        <span class="cov8" title="1">return result.RowsAffected(), nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package database

import (
        "context"
        "fmt"
        "time"

        "github.com/irfndi/celebrum-ai-go/internal/config"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/sirupsen/logrus"
)

type PostgresDB struct {
        Pool *pgxpool.Pool
}

func NewPostgresConnection(cfg *config.DatabaseConfig) (*PostgresDB, error) <span class="cov8" title="1">{
        var dsn string

        // Use DATABASE_URL if provided (common for cloud deployments like Digital Ocean)
        if cfg.DatabaseURL != "" </span><span class="cov8" title="1">{
                dsn = cfg.DatabaseURL
        }</span> else<span class="cov8" title="1"> {
                // Build DSN from individual components
                dsn = fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
                        cfg.Host, cfg.Port, cfg.User, cfg.Password, cfg.DBName, cfg.SSLMode)
        }</span>

        // Parse and configure connection pool
        <span class="cov8" title="1">poolConfig, err := pgxpool.ParseConfig(dsn)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse database config: %w", err)
        }</span>

        // Configure connection pool settings with bounds checking
        <span class="cov8" title="1">if cfg.MaxOpenConns &gt; 0 &amp;&amp; cfg.MaxOpenConns &lt;= 2147483647 </span><span class="cov8" title="1">{
                poolConfig.MaxConns = int32(cfg.MaxOpenConns)
        }</span>
        <span class="cov8" title="1">if cfg.MaxIdleConns &gt; 0 &amp;&amp; cfg.MaxIdleConns &lt;= 2147483647 </span><span class="cov8" title="1">{
                poolConfig.MinConns = int32(cfg.MaxIdleConns)
        }</span>

        // Parse duration strings
        <span class="cov8" title="1">if cfg.ConnMaxLifetime != "" </span><span class="cov8" title="1">{
                if duration, err := time.ParseDuration(cfg.ConnMaxLifetime); err == nil </span><span class="cov0" title="0">{
                        poolConfig.MaxConnLifetime = duration
                }</span>
        }

        <span class="cov8" title="1">if cfg.ConnMaxIdleTime != "" </span><span class="cov8" title="1">{
                if duration, err := time.ParseDuration(cfg.ConnMaxIdleTime); err == nil </span><span class="cov0" title="0">{
                        poolConfig.MaxConnIdleTime = duration
                }</span>
        }

        // Create connection pool with retry logic
        <span class="cov8" title="1">var pool *pgxpool.Pool
        for attempts := 0; attempts &lt; 3; attempts++ </span><span class="cov8" title="1">{
                pool, err = pgxpool.NewWithConfig(context.Background(), poolConfig)
                if err == nil </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov0" title="0">logrus.Warnf("Database connection attempt %d failed: %v", attempts+1, err)
                if attempts &lt; 2 </span><span class="cov0" title="0">{
                        time.Sleep(time.Duration(attempts+1) * time.Second)
                }</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create connection pool after retries: %w", err)
        }</span>

        // Test the connection
        <span class="cov8" title="1">if err := pool.Ping(context.Background()); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to ping database: %w", err)
        }</span>

        <span class="cov0" title="0">logrus.Info("Successfully connected to PostgreSQL")

        return &amp;PostgresDB{Pool: pool}, nil</span>
}

func (db *PostgresDB) Close() <span class="cov8" title="1">{
        if db.Pool != nil </span><span class="cov0" title="0">{
                db.Pool.Close()
                logrus.Info("PostgreSQL connection closed")
        }</span>
}

func (db *PostgresDB) HealthCheck(ctx context.Context) error <span class="cov8" title="1">{
        return db.Pool.Ping(ctx)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package database

import (
        "context"
        "fmt"
        "time"

        "github.com/irfndi/celebrum-ai-go/internal/config"
        "github.com/redis/go-redis/v9"
        "github.com/sirupsen/logrus"
)

// ErrorRecoveryManager interface for dependency injection
type ErrorRecoveryManager interface {
        ExecuteWithRetry(ctx context.Context, operationName string, operation func() error) error
}

type RedisClient struct {
        Client *redis.Client
        logger *logrus.Logger
}

func NewRedisConnection(cfg config.RedisConfig) (*RedisClient, error) <span class="cov8" title="1">{
        return NewRedisConnectionWithRetry(cfg, nil)
}</span>

func NewRedisConnectionWithRetry(cfg config.RedisConfig, errorRecoveryManager ErrorRecoveryManager) (*RedisClient, error) <span class="cov8" title="1">{
        logger := logrus.New()

        rdb := redis.NewClient(&amp;redis.Options{
                Addr:     fmt.Sprintf("%s:%d", cfg.Host, cfg.Port),
                Password: cfg.Password,
                DB:       cfg.DB,
        })

        // Test the connection with retry logic if available
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        var connectionErr error
        if errorRecoveryManager != nil </span><span class="cov8" title="1">{
                // Use retry mechanism
                connectionErr = errorRecoveryManager.ExecuteWithRetry(ctx, "redis_operation", func() error </span><span class="cov0" title="0">{
                        return rdb.Ping(ctx).Err()
                }</span>)
        } else<span class="cov8" title="1"> {
                // Fallback to simple connection test
                connectionErr = rdb.Ping(ctx).Err()
        }</span>

        <span class="cov8" title="1">if connectionErr != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to connect to Redis: %w", connectionErr)
        }</span>

        <span class="cov0" title="0">logger.Info("Successfully connected to Redis")

        return &amp;RedisClient{
                Client: rdb,
                logger: logger,
        }, nil</span>
}

func (r *RedisClient) Close() <span class="cov8" title="1">{
        if r.Client != nil </span><span class="cov0" title="0">{
                if err := r.Client.Close(); err != nil </span><span class="cov0" title="0">{
                        // Log error but don't return it since this is a cleanup function
                        if r.logger != nil </span><span class="cov0" title="0">{
                                r.logger.Errorf("Error closing Redis client: %v", err)
                        }</span> else<span class="cov0" title="0"> {
                                logrus.Errorf("Error closing Redis client: %v", err)
                        }</span>
                }
                <span class="cov0" title="0">if r.logger != nil </span><span class="cov0" title="0">{
                        r.logger.Info("Redis connection closed")
                }</span> else<span class="cov0" title="0"> {
                        logrus.Info("Redis connection closed")
                }</span>
        }
}

func (r *RedisClient) HealthCheck(ctx context.Context) error <span class="cov8" title="1">{
        if r.Client == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("redis client is nil")
        }</span>
        <span class="cov0" title="0">return r.Client.Ping(ctx).Err()</span>
}

// Cache operations
func (r *RedisClient) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error <span class="cov8" title="1">{
        if r.Client == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("redis client is nil")
        }</span>
        <span class="cov0" title="0">return r.Client.Set(ctx, key, value, expiration).Err()</span>
}

func (r *RedisClient) Get(ctx context.Context, key string) (string, error) <span class="cov8" title="1">{
        if r.Client == nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("redis client is nil")
        }</span>
        <span class="cov0" title="0">return r.Client.Get(ctx, key).Result()</span>
}

func (r *RedisClient) Delete(ctx context.Context, keys ...string) error <span class="cov8" title="1">{
        if r.Client == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("redis client is nil")
        }</span>
        <span class="cov0" title="0">return r.Client.Del(ctx, keys...).Err()</span>
}

func (r *RedisClient) Exists(ctx context.Context, keys ...string) (int64, error) <span class="cov8" title="1">{
        if r.Client == nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("redis client is nil")
        }</span>
        <span class="cov0" title="0">return r.Client.Exists(ctx, keys...).Result()</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package database

import (
        "context"
        "fmt"
        "time"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
        "github.com/jackc/pgx/v5/pgxpool"
)

// TracedDB wraps a database connection (stub implementation)
type TracedDB struct {
        Pool *pgxpool.Pool
}

// NewTracedDB creates a new traced database connection
func NewTracedDB(pool *pgxpool.Pool) *TracedDB <span class="cov8" title="1">{
        return &amp;TracedDB{
                Pool: pool,
        }
}</span>

// Query executes a query (stub implementation)
func (db *TracedDB) Query(ctx context.Context, sql string, args ...interface{}) (pgx.Rows, error) <span class="cov8" title="1">{
        start := time.Now()
        rows, err := db.Pool.Query(ctx, sql, args...)
        duration := time.Since(start)

        // Stub logging
        _ = fmt.Sprintf("Query: %s, Duration: %v", sql, duration)
        return rows, err
}</span>

// QueryRow executes a query that returns a single row (stub implementation)
func (db *TracedDB) QueryRow(ctx context.Context, sql string, args ...interface{}) pgx.Row <span class="cov8" title="1">{
        start := time.Now()
        row := db.Pool.QueryRow(ctx, sql, args...)
        duration := time.Since(start)

        // Stub logging
        _ = fmt.Sprintf("QueryRow: %s, Duration: %v", sql, duration)
        return row
}</span>

// Exec executes a query without returning rows (stub implementation)
func (db *TracedDB) Exec(ctx context.Context, sql string, arguments ...interface{}) (pgconn.CommandTag, error) <span class="cov8" title="1">{
        start := time.Now()
        tag, err := db.Pool.Exec(ctx, sql, arguments...)
        duration := time.Since(start)

        // Stub logging
        _ = fmt.Sprintf("Exec: %s, Duration: %v, RowsAffected: %d", sql, duration, tag.RowsAffected())
        return tag, err
}</span>

// Begin starts a transaction (stub implementation)
func (db *TracedDB) Begin(ctx context.Context) (pgx.Tx, error) <span class="cov8" title="1">{
        start := time.Now()
        tx, err := db.Pool.Begin(ctx)
        duration := time.Since(start)

        // Stub logging
        _ = fmt.Sprintf("Begin: Duration: %v", duration)
        return &amp;TracedTx{Tx: tx}, err
}</span>

// BeginTx starts a transaction with options (stub implementation)
func (db *TracedDB) BeginTx(ctx context.Context, txOptions pgx.TxOptions) (pgx.Tx, error) <span class="cov8" title="1">{
        start := time.Now()
        tx, err := db.Pool.BeginTx(ctx, txOptions)
        duration := time.Since(start)

        // Stub logging
        _ = fmt.Sprintf("BeginTx: Duration: %v", duration)
        return &amp;TracedTx{Tx: tx}, err
}</span>

// Ping verifies the connection to the database (stub implementation)
func (db *TracedDB) Ping(ctx context.Context) error <span class="cov8" title="1">{
        start := time.Now()
        err := db.Pool.Ping(ctx)
        duration := time.Since(start)

        // Stub logging
        _ = fmt.Sprintf("Ping: Duration: %v", duration)
        return err
}</span>

// Close closes the database connection pool
func (db *TracedDB) Close() <span class="cov8" title="1">{
        db.Pool.Close()
}</span>

// TracedTx wraps a database transaction (stub implementation)
type TracedTx struct {
        Tx pgx.Tx
}

// Query executes a query within the transaction (stub implementation)
func (tx *TracedTx) Query(ctx context.Context, sql string, args ...interface{}) (pgx.Rows, error) <span class="cov8" title="1">{
        start := time.Now()
        rows, err := tx.Tx.Query(ctx, sql, args...)
        duration := time.Since(start)

        // Stub logging
        _ = fmt.Sprintf("Tx.Query: %s, Duration: %v", sql, duration)
        return rows, err
}</span>

// QueryRow executes a query that returns a single row within the transaction (stub implementation)
func (tx *TracedTx) QueryRow(ctx context.Context, sql string, args ...interface{}) pgx.Row <span class="cov8" title="1">{
        start := time.Now()
        row := tx.Tx.QueryRow(ctx, sql, args...)
        duration := time.Since(start)

        // Stub logging
        _ = fmt.Sprintf("Tx.QueryRow: %s, Duration: %v", sql, duration)
        return row
}</span>

// Exec executes a query without returning rows within the transaction (stub implementation)
func (tx *TracedTx) Exec(ctx context.Context, sql string, args ...interface{}) (pgconn.CommandTag, error) <span class="cov8" title="1">{
        start := time.Now()
        tag, err := tx.Tx.Exec(ctx, sql, args...)
        duration := time.Since(start)

        // Stub logging
        _ = fmt.Sprintf("Tx.Exec: %s, Duration: %v, RowsAffected: %d", sql, duration, tag.RowsAffected())
        return tag, err
}</span>

// Commit commits the transaction (stub implementation)
func (tx *TracedTx) Commit(ctx context.Context) error <span class="cov8" title="1">{
        start := time.Now()
        err := tx.Tx.Commit(ctx)
        duration := time.Since(start)

        // Stub logging
        _ = fmt.Sprintf("Tx.Commit: Duration: %v", duration)
        return err
}</span>

// Rollback rolls back the transaction (stub implementation)
func (tx *TracedTx) Rollback(ctx context.Context) error <span class="cov8" title="1">{
        start := time.Now()
        err := tx.Tx.Rollback(ctx)
        duration := time.Since(start)

        // Stub logging
        _ = fmt.Sprintf("Tx.Rollback: Duration: %v", duration)
        return err
}</span>

// Begin starts a nested transaction (stub implementation)
func (tx *TracedTx) Begin(ctx context.Context) (pgx.Tx, error) <span class="cov8" title="1">{
        start := time.Now()
        nestedTx, err := tx.Tx.Begin(ctx)
        duration := time.Since(start)

        // Stub logging
        _ = fmt.Sprintf("Tx.Begin: Duration: %v", duration)
        return &amp;TracedTx{Tx: nestedTx}, err
}</span>

// Conn returns the underlying connection (stub implementation)
func (tx *TracedTx) Conn() *pgx.Conn <span class="cov8" title="1">{
        return tx.Tx.Conn()
}</span>

// CopyFrom copies data from a source to a destination table (stub implementation)
func (tx *TracedTx) CopyFrom(ctx context.Context, tableName pgx.Identifier, columnNames []string, rowSrc pgx.CopyFromSource) (int64, error) <span class="cov8" title="1">{
        start := time.Now()
        rowsAffected, err := tx.Tx.CopyFrom(ctx, tableName, columnNames, rowSrc)
        duration := time.Since(start)

        // Stub logging
        _ = fmt.Sprintf("Tx.CopyFrom: Table: %v, Duration: %v, RowsAffected: %d", tableName, duration, rowsAffected)
        return rowsAffected, err
}</span>

// LargeObjects returns the large object manager (stub implementation)
func (tx *TracedTx) LargeObjects() pgx.LargeObjects <span class="cov8" title="1">{
        return tx.Tx.LargeObjects()
}</span>

// Prepare prepares a statement (stub implementation)
func (tx *TracedTx) Prepare(ctx context.Context, name, sql string) (*pgconn.StatementDescription, error) <span class="cov8" title="1">{
        start := time.Now()
        stmt, err := tx.Tx.Prepare(ctx, name, sql)
        duration := time.Since(start)

        // Stub logging
        _ = fmt.Sprintf("Tx.Prepare: Name: %s, SQL: %s, Duration: %v", name, sql, duration)
        return stmt, err
}</span>

// SendBatch sends a batch of queries (stub implementation)
func (tx *TracedTx) SendBatch(ctx context.Context, b *pgx.Batch) pgx.BatchResults <span class="cov8" title="1">{
        start := time.Now()
        results := tx.Tx.SendBatch(ctx, b)
        duration := time.Since(start)

        // Stub logging
        _ = fmt.Sprintf("Tx.SendBatch: Duration: %v, BatchSize: %d", duration, b.Len())
        return results
}</span>

// RecordDatabaseError records a database error (stub implementation)
func RecordDatabaseError(ctx context.Context, err error, operation string) <span class="cov8" title="1">{
        // Stub implementation - could log error information
        _ = err
        _ = operation
}</span>

// AddDatabaseSpanAttributes adds database-specific attributes (stub implementation)
func AddDatabaseSpanAttributes(ctx context.Context, table string, rowsAffected int64) <span class="cov8" title="1">{
        // Stub implementation - could log attribute information
        _ = table
        _ = rowsAffected
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
