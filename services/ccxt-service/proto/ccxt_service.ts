// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.10.0
//   protoc               v6.31.1
// source: ccxt_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "ccxt";

export interface GetTickerRequest {
  exchange: string;
  symbol: string;
}

export interface GetTickerResponse {
  exchange: string;
  symbol: string;
  ticker: TickerData | undefined;
  timestamp: number;
  error: string;
}

export interface TickerData {
  last: string;
  high: string;
  low: string;
  bid: string;
  ask: string;
  baseVolume: string;
  quoteVolume: string;
}

export interface GetTickersRequest {
  exchanges: string[];
  symbols: string[];
}

export interface ExchangeTicker {
  exchange: string;
  symbol: string;
  ticker: TickerData | undefined;
  error: string;
  timestamp: number;
}

export interface GetTickersResponse {
  tickers: ExchangeTicker[];
  error: string;
}

export interface GetMarketsRequest {
  exchange: string;
}

export interface GetMarketsResponse {
  exchange: string;
  symbols: string[];
  count: number;
  error: string;
}

export interface GetFundingRatesRequest {
  exchange: string;
  symbols: string[];
}

export interface GetFundingRatesResponse {
  exchange: string;
  rates: FundingRate[];
  error: string;
}

export interface FundingRate {
  symbol: string;
  fundingRate: string;
  timestamp: number;
  nextFundingTime: number;
  markPrice: string;
  indexPrice: string;
}

export interface GetOrderBookRequest {
  exchange: string;
  symbol: string;
  limit: number;
}

export interface GetOrderBookResponse {
  exchange: string;
  symbol: string;
  orderbook: OrderBook | undefined;
  timestamp: number;
  error: string;
}

export interface OrderBook {
  bids: PriceLevel[];
  asks: PriceLevel[];
  timestamp: number;
  nonce: number;
}

export interface PriceLevel {
  price: string;
  amount: string;
}

export interface GetTradesRequest {
  exchange: string;
  symbol: string;
  limit: number;
}

export interface Trade {
  id: string;
  timestamp: number;
  symbol: string;
  side: string;
  amount: string;
  price: string;
  cost: string;
}

export interface GetTradesResponse {
  exchange: string;
  symbol: string;
  trades: Trade[];
  timestamp: number;
  error: string;
}

export interface GetOHLCVRequest {
  exchange: string;
  symbol: string;
  timeframe: string;
  limit: number;
}

export interface GetOHLCVResponse {
  exchange: string;
  symbol: string;
  timeframe: string;
  candles: OHLCV[];
  timestamp: number;
  error: string;
}

export interface OHLCV {
  timestamp: number;
  open: string;
  high: string;
  low: string;
  close: string;
  volume: string;
}

export interface GetExchangesRequest {}

export interface GetExchangesResponse {
  exchanges: ExchangeInfo[];
  error: string;
}

export interface ExchangeInfo {
  id: string;
  name: string;
  countries: string[];
}

export interface HealthCheckRequest {}

export interface HealthCheckResponse {
  status: string;
  version: string;
  service: string;
}

function createBaseGetTickerRequest(): GetTickerRequest {
  return { exchange: "", symbol: "" };
}

export const GetTickerRequest: MessageFns<GetTickerRequest> = {
  encode(
    message: GetTickerRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.exchange !== "") {
      writer.uint32(10).string(message.exchange);
    }
    if (message.symbol !== "") {
      writer.uint32(18).string(message.symbol);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTickerRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTickerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.exchange = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTickerRequest {
    return {
      exchange: isSet(object.exchange)
        ? globalThis.String(object.exchange)
        : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
    };
  },

  toJSON(message: GetTickerRequest): unknown {
    const obj: any = {};
    if (message.exchange !== "") {
      obj.exchange = message.exchange;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTickerRequest>, I>>(
    base?: I,
  ): GetTickerRequest {
    return GetTickerRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTickerRequest>, I>>(
    object: I,
  ): GetTickerRequest {
    const message = createBaseGetTickerRequest();
    message.exchange = object.exchange ?? "";
    message.symbol = object.symbol ?? "";
    return message;
  },
};

function createBaseGetTickerResponse(): GetTickerResponse {
  return {
    exchange: "",
    symbol: "",
    ticker: undefined,
    timestamp: 0,
    error: "",
  };
}

export const GetTickerResponse: MessageFns<GetTickerResponse> = {
  encode(
    message: GetTickerResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.exchange !== "") {
      writer.uint32(10).string(message.exchange);
    }
    if (message.symbol !== "") {
      writer.uint32(18).string(message.symbol);
    }
    if (message.ticker !== undefined) {
      TickerData.encode(message.ticker, writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== 0) {
      writer.uint32(32).int64(message.timestamp);
    }
    if (message.error !== "") {
      writer.uint32(42).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTickerResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTickerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.exchange = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ticker = TickerData.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.timestamp = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTickerResponse {
    return {
      exchange: isSet(object.exchange)
        ? globalThis.String(object.exchange)
        : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      ticker: isSet(object.ticker)
        ? TickerData.fromJSON(object.ticker)
        : undefined,
      timestamp: isSet(object.timestamp)
        ? globalThis.Number(object.timestamp)
        : 0,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: GetTickerResponse): unknown {
    const obj: any = {};
    if (message.exchange !== "") {
      obj.exchange = message.exchange;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.ticker !== undefined) {
      obj.ticker = TickerData.toJSON(message.ticker);
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTickerResponse>, I>>(
    base?: I,
  ): GetTickerResponse {
    return GetTickerResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTickerResponse>, I>>(
    object: I,
  ): GetTickerResponse {
    const message = createBaseGetTickerResponse();
    message.exchange = object.exchange ?? "";
    message.symbol = object.symbol ?? "";
    message.ticker =
      object.ticker !== undefined && object.ticker !== null
        ? TickerData.fromPartial(object.ticker)
        : undefined;
    message.timestamp = object.timestamp ?? 0;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseTickerData(): TickerData {
  return {
    last: "",
    high: "",
    low: "",
    bid: "",
    ask: "",
    baseVolume: "",
    quoteVolume: "",
  };
}

export const TickerData: MessageFns<TickerData> = {
  encode(
    message: TickerData,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.last !== "") {
      writer.uint32(10).string(message.last);
    }
    if (message.high !== "") {
      writer.uint32(18).string(message.high);
    }
    if (message.low !== "") {
      writer.uint32(26).string(message.low);
    }
    if (message.bid !== "") {
      writer.uint32(34).string(message.bid);
    }
    if (message.ask !== "") {
      writer.uint32(42).string(message.ask);
    }
    if (message.baseVolume !== "") {
      writer.uint32(50).string(message.baseVolume);
    }
    if (message.quoteVolume !== "") {
      writer.uint32(58).string(message.quoteVolume);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TickerData {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTickerData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.last = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.high = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.low = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bid = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.ask = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.baseVolume = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.quoteVolume = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TickerData {
    return {
      last: isSet(object.last) ? globalThis.String(object.last) : "",
      high: isSet(object.high) ? globalThis.String(object.high) : "",
      low: isSet(object.low) ? globalThis.String(object.low) : "",
      bid: isSet(object.bid) ? globalThis.String(object.bid) : "",
      ask: isSet(object.ask) ? globalThis.String(object.ask) : "",
      baseVolume: isSet(object.baseVolume)
        ? globalThis.String(object.baseVolume)
        : "",
      quoteVolume: isSet(object.quoteVolume)
        ? globalThis.String(object.quoteVolume)
        : "",
    };
  },

  toJSON(message: TickerData): unknown {
    const obj: any = {};
    if (message.last !== "") {
      obj.last = message.last;
    }
    if (message.high !== "") {
      obj.high = message.high;
    }
    if (message.low !== "") {
      obj.low = message.low;
    }
    if (message.bid !== "") {
      obj.bid = message.bid;
    }
    if (message.ask !== "") {
      obj.ask = message.ask;
    }
    if (message.baseVolume !== "") {
      obj.baseVolume = message.baseVolume;
    }
    if (message.quoteVolume !== "") {
      obj.quoteVolume = message.quoteVolume;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TickerData>, I>>(base?: I): TickerData {
    return TickerData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TickerData>, I>>(
    object: I,
  ): TickerData {
    const message = createBaseTickerData();
    message.last = object.last ?? "";
    message.high = object.high ?? "";
    message.low = object.low ?? "";
    message.bid = object.bid ?? "";
    message.ask = object.ask ?? "";
    message.baseVolume = object.baseVolume ?? "";
    message.quoteVolume = object.quoteVolume ?? "";
    return message;
  },
};

function createBaseGetTickersRequest(): GetTickersRequest {
  return { exchanges: [], symbols: [] };
}

export const GetTickersRequest: MessageFns<GetTickersRequest> = {
  encode(
    message: GetTickersRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.exchanges) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.symbols) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTickersRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTickersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.exchanges.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.symbols.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTickersRequest {
    return {
      exchanges: globalThis.Array.isArray(object?.exchanges)
        ? object.exchanges.map((e: any) => globalThis.String(e))
        : [],
      symbols: globalThis.Array.isArray(object?.symbols)
        ? object.symbols.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetTickersRequest): unknown {
    const obj: any = {};
    if (message.exchanges?.length) {
      obj.exchanges = message.exchanges;
    }
    if (message.symbols?.length) {
      obj.symbols = message.symbols;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTickersRequest>, I>>(
    base?: I,
  ): GetTickersRequest {
    return GetTickersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTickersRequest>, I>>(
    object: I,
  ): GetTickersRequest {
    const message = createBaseGetTickersRequest();
    message.exchanges = object.exchanges?.map((e) => e) || [];
    message.symbols = object.symbols?.map((e) => e) || [];
    return message;
  },
};

function createBaseExchangeTicker(): ExchangeTicker {
  return {
    exchange: "",
    symbol: "",
    ticker: undefined,
    error: "",
    timestamp: 0,
  };
}

export const ExchangeTicker: MessageFns<ExchangeTicker> = {
  encode(
    message: ExchangeTicker,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.exchange !== "") {
      writer.uint32(10).string(message.exchange);
    }
    if (message.symbol !== "") {
      writer.uint32(18).string(message.symbol);
    }
    if (message.ticker !== undefined) {
      TickerData.encode(message.ticker, writer.uint32(26).fork()).join();
    }
    if (message.error !== "") {
      writer.uint32(34).string(message.error);
    }
    if (message.timestamp !== 0) {
      writer.uint32(40).int64(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExchangeTicker {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExchangeTicker();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.exchange = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ticker = TickerData.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.timestamp = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExchangeTicker {
    return {
      exchange: isSet(object.exchange)
        ? globalThis.String(object.exchange)
        : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      ticker: isSet(object.ticker)
        ? TickerData.fromJSON(object.ticker)
        : undefined,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      timestamp: isSet(object.timestamp)
        ? globalThis.Number(object.timestamp)
        : 0,
    };
  },

  toJSON(message: ExchangeTicker): unknown {
    const obj: any = {};
    if (message.exchange !== "") {
      obj.exchange = message.exchange;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.ticker !== undefined) {
      obj.ticker = TickerData.toJSON(message.ticker);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExchangeTicker>, I>>(
    base?: I,
  ): ExchangeTicker {
    return ExchangeTicker.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExchangeTicker>, I>>(
    object: I,
  ): ExchangeTicker {
    const message = createBaseExchangeTicker();
    message.exchange = object.exchange ?? "";
    message.symbol = object.symbol ?? "";
    message.ticker =
      object.ticker !== undefined && object.ticker !== null
        ? TickerData.fromPartial(object.ticker)
        : undefined;
    message.error = object.error ?? "";
    message.timestamp = object.timestamp ?? 0;
    return message;
  },
};

function createBaseGetTickersResponse(): GetTickersResponse {
  return { tickers: [], error: "" };
}

export const GetTickersResponse: MessageFns<GetTickersResponse> = {
  encode(
    message: GetTickersResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.tickers) {
      ExchangeTicker.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetTickersResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTickersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tickers.push(ExchangeTicker.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTickersResponse {
    return {
      tickers: globalThis.Array.isArray(object?.tickers)
        ? object.tickers.map((e: any) => ExchangeTicker.fromJSON(e))
        : [],
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: GetTickersResponse): unknown {
    const obj: any = {};
    if (message.tickers?.length) {
      obj.tickers = message.tickers.map((e) => ExchangeTicker.toJSON(e));
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTickersResponse>, I>>(
    base?: I,
  ): GetTickersResponse {
    return GetTickersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTickersResponse>, I>>(
    object: I,
  ): GetTickersResponse {
    const message = createBaseGetTickersResponse();
    message.tickers =
      object.tickers?.map((e) => ExchangeTicker.fromPartial(e)) || [];
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseGetMarketsRequest(): GetMarketsRequest {
  return { exchange: "" };
}

export const GetMarketsRequest: MessageFns<GetMarketsRequest> = {
  encode(
    message: GetMarketsRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.exchange !== "") {
      writer.uint32(10).string(message.exchange);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMarketsRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMarketsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.exchange = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMarketsRequest {
    return {
      exchange: isSet(object.exchange)
        ? globalThis.String(object.exchange)
        : "",
    };
  },

  toJSON(message: GetMarketsRequest): unknown {
    const obj: any = {};
    if (message.exchange !== "") {
      obj.exchange = message.exchange;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMarketsRequest>, I>>(
    base?: I,
  ): GetMarketsRequest {
    return GetMarketsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMarketsRequest>, I>>(
    object: I,
  ): GetMarketsRequest {
    const message = createBaseGetMarketsRequest();
    message.exchange = object.exchange ?? "";
    return message;
  },
};

function createBaseGetMarketsResponse(): GetMarketsResponse {
  return { exchange: "", symbols: [], count: 0, error: "" };
}

export const GetMarketsResponse: MessageFns<GetMarketsResponse> = {
  encode(
    message: GetMarketsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.exchange !== "") {
      writer.uint32(10).string(message.exchange);
    }
    for (const v of message.symbols) {
      writer.uint32(18).string(v!);
    }
    if (message.count !== 0) {
      writer.uint32(24).int32(message.count);
    }
    if (message.error !== "") {
      writer.uint32(34).string(message.error);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetMarketsResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMarketsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.exchange = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.symbols.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMarketsResponse {
    return {
      exchange: isSet(object.exchange)
        ? globalThis.String(object.exchange)
        : "",
      symbols: globalThis.Array.isArray(object?.symbols)
        ? object.symbols.map((e: any) => globalThis.String(e))
        : [],
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: GetMarketsResponse): unknown {
    const obj: any = {};
    if (message.exchange !== "") {
      obj.exchange = message.exchange;
    }
    if (message.symbols?.length) {
      obj.symbols = message.symbols;
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMarketsResponse>, I>>(
    base?: I,
  ): GetMarketsResponse {
    return GetMarketsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMarketsResponse>, I>>(
    object: I,
  ): GetMarketsResponse {
    const message = createBaseGetMarketsResponse();
    message.exchange = object.exchange ?? "";
    message.symbols = object.symbols?.map((e) => e) || [];
    message.count = object.count ?? 0;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseGetFundingRatesRequest(): GetFundingRatesRequest {
  return { exchange: "", symbols: [] };
}

export const GetFundingRatesRequest: MessageFns<GetFundingRatesRequest> = {
  encode(
    message: GetFundingRatesRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.exchange !== "") {
      writer.uint32(10).string(message.exchange);
    }
    for (const v of message.symbols) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetFundingRatesRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFundingRatesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.exchange = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.symbols.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFundingRatesRequest {
    return {
      exchange: isSet(object.exchange)
        ? globalThis.String(object.exchange)
        : "",
      symbols: globalThis.Array.isArray(object?.symbols)
        ? object.symbols.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetFundingRatesRequest): unknown {
    const obj: any = {};
    if (message.exchange !== "") {
      obj.exchange = message.exchange;
    }
    if (message.symbols?.length) {
      obj.symbols = message.symbols;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetFundingRatesRequest>, I>>(
    base?: I,
  ): GetFundingRatesRequest {
    return GetFundingRatesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetFundingRatesRequest>, I>>(
    object: I,
  ): GetFundingRatesRequest {
    const message = createBaseGetFundingRatesRequest();
    message.exchange = object.exchange ?? "";
    message.symbols = object.symbols?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetFundingRatesResponse(): GetFundingRatesResponse {
  return { exchange: "", rates: [], error: "" };
}

export const GetFundingRatesResponse: MessageFns<GetFundingRatesResponse> = {
  encode(
    message: GetFundingRatesResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.exchange !== "") {
      writer.uint32(10).string(message.exchange);
    }
    for (const v of message.rates) {
      FundingRate.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetFundingRatesResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFundingRatesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.exchange = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rates.push(FundingRate.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFundingRatesResponse {
    return {
      exchange: isSet(object.exchange)
        ? globalThis.String(object.exchange)
        : "",
      rates: globalThis.Array.isArray(object?.rates)
        ? object.rates.map((e: any) => FundingRate.fromJSON(e))
        : [],
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: GetFundingRatesResponse): unknown {
    const obj: any = {};
    if (message.exchange !== "") {
      obj.exchange = message.exchange;
    }
    if (message.rates?.length) {
      obj.rates = message.rates.map((e) => FundingRate.toJSON(e));
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetFundingRatesResponse>, I>>(
    base?: I,
  ): GetFundingRatesResponse {
    return GetFundingRatesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetFundingRatesResponse>, I>>(
    object: I,
  ): GetFundingRatesResponse {
    const message = createBaseGetFundingRatesResponse();
    message.exchange = object.exchange ?? "";
    message.rates = object.rates?.map((e) => FundingRate.fromPartial(e)) || [];
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseFundingRate(): FundingRate {
  return {
    symbol: "",
    fundingRate: "",
    timestamp: 0,
    nextFundingTime: 0,
    markPrice: "",
    indexPrice: "",
  };
}

export const FundingRate: MessageFns<FundingRate> = {
  encode(
    message: FundingRate,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.symbol !== "") {
      writer.uint32(10).string(message.symbol);
    }
    if (message.fundingRate !== "") {
      writer.uint32(18).string(message.fundingRate);
    }
    if (message.timestamp !== 0) {
      writer.uint32(24).int64(message.timestamp);
    }
    if (message.nextFundingTime !== 0) {
      writer.uint32(32).int64(message.nextFundingTime);
    }
    if (message.markPrice !== "") {
      writer.uint32(42).string(message.markPrice);
    }
    if (message.indexPrice !== "") {
      writer.uint32(50).string(message.indexPrice);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FundingRate {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFundingRate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fundingRate = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.timestamp = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.nextFundingTime = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.markPrice = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.indexPrice = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FundingRate {
    return {
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      fundingRate: isSet(object.fundingRate)
        ? globalThis.String(object.fundingRate)
        : "",
      timestamp: isSet(object.timestamp)
        ? globalThis.Number(object.timestamp)
        : 0,
      nextFundingTime: isSet(object.nextFundingTime)
        ? globalThis.Number(object.nextFundingTime)
        : 0,
      markPrice: isSet(object.markPrice)
        ? globalThis.String(object.markPrice)
        : "",
      indexPrice: isSet(object.indexPrice)
        ? globalThis.String(object.indexPrice)
        : "",
    };
  },

  toJSON(message: FundingRate): unknown {
    const obj: any = {};
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.fundingRate !== "") {
      obj.fundingRate = message.fundingRate;
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.nextFundingTime !== 0) {
      obj.nextFundingTime = Math.round(message.nextFundingTime);
    }
    if (message.markPrice !== "") {
      obj.markPrice = message.markPrice;
    }
    if (message.indexPrice !== "") {
      obj.indexPrice = message.indexPrice;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FundingRate>, I>>(base?: I): FundingRate {
    return FundingRate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FundingRate>, I>>(
    object: I,
  ): FundingRate {
    const message = createBaseFundingRate();
    message.symbol = object.symbol ?? "";
    message.fundingRate = object.fundingRate ?? "";
    message.timestamp = object.timestamp ?? 0;
    message.nextFundingTime = object.nextFundingTime ?? 0;
    message.markPrice = object.markPrice ?? "";
    message.indexPrice = object.indexPrice ?? "";
    return message;
  },
};

function createBaseGetOrderBookRequest(): GetOrderBookRequest {
  return { exchange: "", symbol: "", limit: 0 };
}

export const GetOrderBookRequest: MessageFns<GetOrderBookRequest> = {
  encode(
    message: GetOrderBookRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.exchange !== "") {
      writer.uint32(10).string(message.exchange);
    }
    if (message.symbol !== "") {
      writer.uint32(18).string(message.symbol);
    }
    if (message.limit !== 0) {
      writer.uint32(24).int32(message.limit);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetOrderBookRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrderBookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.exchange = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOrderBookRequest {
    return {
      exchange: isSet(object.exchange)
        ? globalThis.String(object.exchange)
        : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
    };
  },

  toJSON(message: GetOrderBookRequest): unknown {
    const obj: any = {};
    if (message.exchange !== "") {
      obj.exchange = message.exchange;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOrderBookRequest>, I>>(
    base?: I,
  ): GetOrderBookRequest {
    return GetOrderBookRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOrderBookRequest>, I>>(
    object: I,
  ): GetOrderBookRequest {
    const message = createBaseGetOrderBookRequest();
    message.exchange = object.exchange ?? "";
    message.symbol = object.symbol ?? "";
    message.limit = object.limit ?? 0;
    return message;
  },
};

function createBaseGetOrderBookResponse(): GetOrderBookResponse {
  return {
    exchange: "",
    symbol: "",
    orderbook: undefined,
    timestamp: 0,
    error: "",
  };
}

export const GetOrderBookResponse: MessageFns<GetOrderBookResponse> = {
  encode(
    message: GetOrderBookResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.exchange !== "") {
      writer.uint32(10).string(message.exchange);
    }
    if (message.symbol !== "") {
      writer.uint32(18).string(message.symbol);
    }
    if (message.orderbook !== undefined) {
      OrderBook.encode(message.orderbook, writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== 0) {
      writer.uint32(32).int64(message.timestamp);
    }
    if (message.error !== "") {
      writer.uint32(42).string(message.error);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetOrderBookResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrderBookResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.exchange = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.orderbook = OrderBook.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.timestamp = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOrderBookResponse {
    return {
      exchange: isSet(object.exchange)
        ? globalThis.String(object.exchange)
        : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      orderbook: isSet(object.orderbook)
        ? OrderBook.fromJSON(object.orderbook)
        : undefined,
      timestamp: isSet(object.timestamp)
        ? globalThis.Number(object.timestamp)
        : 0,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: GetOrderBookResponse): unknown {
    const obj: any = {};
    if (message.exchange !== "") {
      obj.exchange = message.exchange;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.orderbook !== undefined) {
      obj.orderbook = OrderBook.toJSON(message.orderbook);
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOrderBookResponse>, I>>(
    base?: I,
  ): GetOrderBookResponse {
    return GetOrderBookResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOrderBookResponse>, I>>(
    object: I,
  ): GetOrderBookResponse {
    const message = createBaseGetOrderBookResponse();
    message.exchange = object.exchange ?? "";
    message.symbol = object.symbol ?? "";
    message.orderbook =
      object.orderbook !== undefined && object.orderbook !== null
        ? OrderBook.fromPartial(object.orderbook)
        : undefined;
    message.timestamp = object.timestamp ?? 0;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseOrderBook(): OrderBook {
  return { bids: [], asks: [], timestamp: 0, nonce: 0 };
}

export const OrderBook: MessageFns<OrderBook> = {
  encode(
    message: OrderBook,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.bids) {
      PriceLevel.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.asks) {
      PriceLevel.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.timestamp !== 0) {
      writer.uint32(24).int64(message.timestamp);
    }
    if (message.nonce !== 0) {
      writer.uint32(32).int64(message.nonce);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderBook {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderBook();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bids.push(PriceLevel.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.asks.push(PriceLevel.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.timestamp = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.nonce = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderBook {
    return {
      bids: globalThis.Array.isArray(object?.bids)
        ? object.bids.map((e: any) => PriceLevel.fromJSON(e))
        : [],
      asks: globalThis.Array.isArray(object?.asks)
        ? object.asks.map((e: any) => PriceLevel.fromJSON(e))
        : [],
      timestamp: isSet(object.timestamp)
        ? globalThis.Number(object.timestamp)
        : 0,
      nonce: isSet(object.nonce) ? globalThis.Number(object.nonce) : 0,
    };
  },

  toJSON(message: OrderBook): unknown {
    const obj: any = {};
    if (message.bids?.length) {
      obj.bids = message.bids.map((e) => PriceLevel.toJSON(e));
    }
    if (message.asks?.length) {
      obj.asks = message.asks.map((e) => PriceLevel.toJSON(e));
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.nonce !== 0) {
      obj.nonce = Math.round(message.nonce);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderBook>, I>>(base?: I): OrderBook {
    return OrderBook.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderBook>, I>>(
    object: I,
  ): OrderBook {
    const message = createBaseOrderBook();
    message.bids = object.bids?.map((e) => PriceLevel.fromPartial(e)) || [];
    message.asks = object.asks?.map((e) => PriceLevel.fromPartial(e)) || [];
    message.timestamp = object.timestamp ?? 0;
    message.nonce = object.nonce ?? 0;
    return message;
  },
};

function createBasePriceLevel(): PriceLevel {
  return { price: "", amount: "" };
}

export const PriceLevel: MessageFns<PriceLevel> = {
  encode(
    message: PriceLevel,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.price !== "") {
      writer.uint32(10).string(message.price);
    }
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PriceLevel {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePriceLevel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.price = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PriceLevel {
    return {
      price: isSet(object.price) ? globalThis.String(object.price) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
    };
  },

  toJSON(message: PriceLevel): unknown {
    const obj: any = {};
    if (message.price !== "") {
      obj.price = message.price;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PriceLevel>, I>>(base?: I): PriceLevel {
    return PriceLevel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PriceLevel>, I>>(
    object: I,
  ): PriceLevel {
    const message = createBasePriceLevel();
    message.price = object.price ?? "";
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBaseGetTradesRequest(): GetTradesRequest {
  return { exchange: "", symbol: "", limit: 0 };
}

export const GetTradesRequest: MessageFns<GetTradesRequest> = {
  encode(
    message: GetTradesRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.exchange !== "") {
      writer.uint32(10).string(message.exchange);
    }
    if (message.symbol !== "") {
      writer.uint32(18).string(message.symbol);
    }
    if (message.limit !== 0) {
      writer.uint32(24).int32(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTradesRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTradesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.exchange = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTradesRequest {
    return {
      exchange: isSet(object.exchange)
        ? globalThis.String(object.exchange)
        : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
    };
  },

  toJSON(message: GetTradesRequest): unknown {
    const obj: any = {};
    if (message.exchange !== "") {
      obj.exchange = message.exchange;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTradesRequest>, I>>(
    base?: I,
  ): GetTradesRequest {
    return GetTradesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTradesRequest>, I>>(
    object: I,
  ): GetTradesRequest {
    const message = createBaseGetTradesRequest();
    message.exchange = object.exchange ?? "";
    message.symbol = object.symbol ?? "";
    message.limit = object.limit ?? 0;
    return message;
  },
};

function createBaseTrade(): Trade {
  return {
    id: "",
    timestamp: 0,
    symbol: "",
    side: "",
    amount: "",
    price: "",
    cost: "",
  };
}

export const Trade: MessageFns<Trade> = {
  encode(
    message: Trade,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.timestamp !== 0) {
      writer.uint32(16).int64(message.timestamp);
    }
    if (message.symbol !== "") {
      writer.uint32(26).string(message.symbol);
    }
    if (message.side !== "") {
      writer.uint32(34).string(message.side);
    }
    if (message.amount !== "") {
      writer.uint32(42).string(message.amount);
    }
    if (message.price !== "") {
      writer.uint32(50).string(message.price);
    }
    if (message.cost !== "") {
      writer.uint32(58).string(message.cost);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Trade {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrade();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.timestamp = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.side = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.price = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.cost = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Trade {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      timestamp: isSet(object.timestamp)
        ? globalThis.Number(object.timestamp)
        : 0,
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      side: isSet(object.side) ? globalThis.String(object.side) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      price: isSet(object.price) ? globalThis.String(object.price) : "",
      cost: isSet(object.cost) ? globalThis.String(object.cost) : "",
    };
  },

  toJSON(message: Trade): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.side !== "") {
      obj.side = message.side;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.price !== "") {
      obj.price = message.price;
    }
    if (message.cost !== "") {
      obj.cost = message.cost;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Trade>, I>>(base?: I): Trade {
    return Trade.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Trade>, I>>(object: I): Trade {
    const message = createBaseTrade();
    message.id = object.id ?? "";
    message.timestamp = object.timestamp ?? 0;
    message.symbol = object.symbol ?? "";
    message.side = object.side ?? "";
    message.amount = object.amount ?? "";
    message.price = object.price ?? "";
    message.cost = object.cost ?? "";
    return message;
  },
};

function createBaseGetTradesResponse(): GetTradesResponse {
  return { exchange: "", symbol: "", trades: [], timestamp: 0, error: "" };
}

export const GetTradesResponse: MessageFns<GetTradesResponse> = {
  encode(
    message: GetTradesResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.exchange !== "") {
      writer.uint32(10).string(message.exchange);
    }
    if (message.symbol !== "") {
      writer.uint32(18).string(message.symbol);
    }
    for (const v of message.trades) {
      Trade.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== 0) {
      writer.uint32(32).int64(message.timestamp);
    }
    if (message.error !== "") {
      writer.uint32(42).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTradesResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTradesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.exchange = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.trades.push(Trade.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.timestamp = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTradesResponse {
    return {
      exchange: isSet(object.exchange)
        ? globalThis.String(object.exchange)
        : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      trades: globalThis.Array.isArray(object?.trades)
        ? object.trades.map((e: any) => Trade.fromJSON(e))
        : [],
      timestamp: isSet(object.timestamp)
        ? globalThis.Number(object.timestamp)
        : 0,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: GetTradesResponse): unknown {
    const obj: any = {};
    if (message.exchange !== "") {
      obj.exchange = message.exchange;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.trades?.length) {
      obj.trades = message.trades.map((e) => Trade.toJSON(e));
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTradesResponse>, I>>(
    base?: I,
  ): GetTradesResponse {
    return GetTradesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTradesResponse>, I>>(
    object: I,
  ): GetTradesResponse {
    const message = createBaseGetTradesResponse();
    message.exchange = object.exchange ?? "";
    message.symbol = object.symbol ?? "";
    message.trades = object.trades?.map((e) => Trade.fromPartial(e)) || [];
    message.timestamp = object.timestamp ?? 0;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseGetOHLCVRequest(): GetOHLCVRequest {
  return { exchange: "", symbol: "", timeframe: "", limit: 0 };
}

export const GetOHLCVRequest: MessageFns<GetOHLCVRequest> = {
  encode(
    message: GetOHLCVRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.exchange !== "") {
      writer.uint32(10).string(message.exchange);
    }
    if (message.symbol !== "") {
      writer.uint32(18).string(message.symbol);
    }
    if (message.timeframe !== "") {
      writer.uint32(26).string(message.timeframe);
    }
    if (message.limit !== 0) {
      writer.uint32(32).int32(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOHLCVRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOHLCVRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.exchange = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.timeframe = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOHLCVRequest {
    return {
      exchange: isSet(object.exchange)
        ? globalThis.String(object.exchange)
        : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      timeframe: isSet(object.timeframe)
        ? globalThis.String(object.timeframe)
        : "",
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
    };
  },

  toJSON(message: GetOHLCVRequest): unknown {
    const obj: any = {};
    if (message.exchange !== "") {
      obj.exchange = message.exchange;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.timeframe !== "") {
      obj.timeframe = message.timeframe;
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOHLCVRequest>, I>>(
    base?: I,
  ): GetOHLCVRequest {
    return GetOHLCVRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOHLCVRequest>, I>>(
    object: I,
  ): GetOHLCVRequest {
    const message = createBaseGetOHLCVRequest();
    message.exchange = object.exchange ?? "";
    message.symbol = object.symbol ?? "";
    message.timeframe = object.timeframe ?? "";
    message.limit = object.limit ?? 0;
    return message;
  },
};

function createBaseGetOHLCVResponse(): GetOHLCVResponse {
  return {
    exchange: "",
    symbol: "",
    timeframe: "",
    candles: [],
    timestamp: 0,
    error: "",
  };
}

export const GetOHLCVResponse: MessageFns<GetOHLCVResponse> = {
  encode(
    message: GetOHLCVResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.exchange !== "") {
      writer.uint32(10).string(message.exchange);
    }
    if (message.symbol !== "") {
      writer.uint32(18).string(message.symbol);
    }
    if (message.timeframe !== "") {
      writer.uint32(26).string(message.timeframe);
    }
    for (const v of message.candles) {
      OHLCV.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.timestamp !== 0) {
      writer.uint32(40).int64(message.timestamp);
    }
    if (message.error !== "") {
      writer.uint32(50).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOHLCVResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOHLCVResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.exchange = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.timeframe = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.candles.push(OHLCV.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.timestamp = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOHLCVResponse {
    return {
      exchange: isSet(object.exchange)
        ? globalThis.String(object.exchange)
        : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      timeframe: isSet(object.timeframe)
        ? globalThis.String(object.timeframe)
        : "",
      candles: globalThis.Array.isArray(object?.candles)
        ? object.candles.map((e: any) => OHLCV.fromJSON(e))
        : [],
      timestamp: isSet(object.timestamp)
        ? globalThis.Number(object.timestamp)
        : 0,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: GetOHLCVResponse): unknown {
    const obj: any = {};
    if (message.exchange !== "") {
      obj.exchange = message.exchange;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.timeframe !== "") {
      obj.timeframe = message.timeframe;
    }
    if (message.candles?.length) {
      obj.candles = message.candles.map((e) => OHLCV.toJSON(e));
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOHLCVResponse>, I>>(
    base?: I,
  ): GetOHLCVResponse {
    return GetOHLCVResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOHLCVResponse>, I>>(
    object: I,
  ): GetOHLCVResponse {
    const message = createBaseGetOHLCVResponse();
    message.exchange = object.exchange ?? "";
    message.symbol = object.symbol ?? "";
    message.timeframe = object.timeframe ?? "";
    message.candles = object.candles?.map((e) => OHLCV.fromPartial(e)) || [];
    message.timestamp = object.timestamp ?? 0;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseOHLCV(): OHLCV {
  return { timestamp: 0, open: "", high: "", low: "", close: "", volume: "" };
}

export const OHLCV: MessageFns<OHLCV> = {
  encode(
    message: OHLCV,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.timestamp !== 0) {
      writer.uint32(8).int64(message.timestamp);
    }
    if (message.open !== "") {
      writer.uint32(18).string(message.open);
    }
    if (message.high !== "") {
      writer.uint32(26).string(message.high);
    }
    if (message.low !== "") {
      writer.uint32(34).string(message.low);
    }
    if (message.close !== "") {
      writer.uint32(42).string(message.close);
    }
    if (message.volume !== "") {
      writer.uint32(50).string(message.volume);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OHLCV {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOHLCV();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.timestamp = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.open = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.high = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.low = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.close = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.volume = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OHLCV {
    return {
      timestamp: isSet(object.timestamp)
        ? globalThis.Number(object.timestamp)
        : 0,
      open: isSet(object.open) ? globalThis.String(object.open) : "",
      high: isSet(object.high) ? globalThis.String(object.high) : "",
      low: isSet(object.low) ? globalThis.String(object.low) : "",
      close: isSet(object.close) ? globalThis.String(object.close) : "",
      volume: isSet(object.volume) ? globalThis.String(object.volume) : "",
    };
  },

  toJSON(message: OHLCV): unknown {
    const obj: any = {};
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.open !== "") {
      obj.open = message.open;
    }
    if (message.high !== "") {
      obj.high = message.high;
    }
    if (message.low !== "") {
      obj.low = message.low;
    }
    if (message.close !== "") {
      obj.close = message.close;
    }
    if (message.volume !== "") {
      obj.volume = message.volume;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OHLCV>, I>>(base?: I): OHLCV {
    return OHLCV.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OHLCV>, I>>(object: I): OHLCV {
    const message = createBaseOHLCV();
    message.timestamp = object.timestamp ?? 0;
    message.open = object.open ?? "";
    message.high = object.high ?? "";
    message.low = object.low ?? "";
    message.close = object.close ?? "";
    message.volume = object.volume ?? "";
    return message;
  },
};

function createBaseGetExchangesRequest(): GetExchangesRequest {
  return {};
}

export const GetExchangesRequest: MessageFns<GetExchangesRequest> = {
  encode(
    _: GetExchangesRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetExchangesRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExchangesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetExchangesRequest {
    return {};
  },

  toJSON(_: GetExchangesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetExchangesRequest>, I>>(
    base?: I,
  ): GetExchangesRequest {
    return GetExchangesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetExchangesRequest>, I>>(
    _: I,
  ): GetExchangesRequest {
    const message = createBaseGetExchangesRequest();
    return message;
  },
};

function createBaseGetExchangesResponse(): GetExchangesResponse {
  return { exchanges: [], error: "" };
}

export const GetExchangesResponse: MessageFns<GetExchangesResponse> = {
  encode(
    message: GetExchangesResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.exchanges) {
      ExchangeInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetExchangesResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExchangesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.exchanges.push(ExchangeInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetExchangesResponse {
    return {
      exchanges: globalThis.Array.isArray(object?.exchanges)
        ? object.exchanges.map((e: any) => ExchangeInfo.fromJSON(e))
        : [],
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: GetExchangesResponse): unknown {
    const obj: any = {};
    if (message.exchanges?.length) {
      obj.exchanges = message.exchanges.map((e) => ExchangeInfo.toJSON(e));
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetExchangesResponse>, I>>(
    base?: I,
  ): GetExchangesResponse {
    return GetExchangesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetExchangesResponse>, I>>(
    object: I,
  ): GetExchangesResponse {
    const message = createBaseGetExchangesResponse();
    message.exchanges =
      object.exchanges?.map((e) => ExchangeInfo.fromPartial(e)) || [];
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseExchangeInfo(): ExchangeInfo {
  return { id: "", name: "", countries: [] };
}

export const ExchangeInfo: MessageFns<ExchangeInfo> = {
  encode(
    message: ExchangeInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    for (const v of message.countries) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExchangeInfo {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExchangeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.countries.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExchangeInfo {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      countries: globalThis.Array.isArray(object?.countries)
        ? object.countries.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ExchangeInfo): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.countries?.length) {
      obj.countries = message.countries;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExchangeInfo>, I>>(
    base?: I,
  ): ExchangeInfo {
    return ExchangeInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExchangeInfo>, I>>(
    object: I,
  ): ExchangeInfo {
    const message = createBaseExchangeInfo();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.countries = object.countries?.map((e) => e) || [];
    return message;
  },
};

function createBaseHealthCheckRequest(): HealthCheckRequest {
  return {};
}

export const HealthCheckRequest: MessageFns<HealthCheckRequest> = {
  encode(
    _: HealthCheckRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): HealthCheckRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): HealthCheckRequest {
    return {};
  },

  toJSON(_: HealthCheckRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheckRequest>, I>>(
    base?: I,
  ): HealthCheckRequest {
    return HealthCheckRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheckRequest>, I>>(
    _: I,
  ): HealthCheckRequest {
    const message = createBaseHealthCheckRequest();
    return message;
  },
};

function createBaseHealthCheckResponse(): HealthCheckResponse {
  return { status: "", version: "", service: "" };
}

export const HealthCheckResponse: MessageFns<HealthCheckResponse> = {
  encode(
    message: HealthCheckResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.service !== "") {
      writer.uint32(26).string(message.service);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): HealthCheckResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.service = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheckResponse {
    return {
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      service: isSet(object.service) ? globalThis.String(object.service) : "",
    };
  },

  toJSON(message: HealthCheckResponse): unknown {
    const obj: any = {};
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.service !== "") {
      obj.service = message.service;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheckResponse>, I>>(
    base?: I,
  ): HealthCheckResponse {
    return HealthCheckResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheckResponse>, I>>(
    object: I,
  ): HealthCheckResponse {
    const message = createBaseHealthCheckResponse();
    message.status = object.status ?? "";
    message.version = object.version ?? "";
    message.service = object.service ?? "";
    return message;
  },
};

export type CcxtServiceService = typeof CcxtServiceService;
export const CcxtServiceService = {
  getTicker: {
    path: "/ccxt.CcxtService/GetTicker",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetTickerRequest): Buffer =>
      Buffer.from(GetTickerRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetTickerRequest =>
      GetTickerRequest.decode(value),
    responseSerialize: (value: GetTickerResponse): Buffer =>
      Buffer.from(GetTickerResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetTickerResponse =>
      GetTickerResponse.decode(value),
  },
  getMarkets: {
    path: "/ccxt.CcxtService/GetMarkets",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetMarketsRequest): Buffer =>
      Buffer.from(GetMarketsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetMarketsRequest =>
      GetMarketsRequest.decode(value),
    responseSerialize: (value: GetMarketsResponse): Buffer =>
      Buffer.from(GetMarketsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetMarketsResponse =>
      GetMarketsResponse.decode(value),
  },
  getFundingRates: {
    path: "/ccxt.CcxtService/GetFundingRates",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetFundingRatesRequest): Buffer =>
      Buffer.from(GetFundingRatesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetFundingRatesRequest =>
      GetFundingRatesRequest.decode(value),
    responseSerialize: (value: GetFundingRatesResponse): Buffer =>
      Buffer.from(GetFundingRatesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetFundingRatesResponse =>
      GetFundingRatesResponse.decode(value),
  },
  getOrderBook: {
    path: "/ccxt.CcxtService/GetOrderBook",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetOrderBookRequest): Buffer =>
      Buffer.from(GetOrderBookRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetOrderBookRequest =>
      GetOrderBookRequest.decode(value),
    responseSerialize: (value: GetOrderBookResponse): Buffer =>
      Buffer.from(GetOrderBookResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetOrderBookResponse =>
      GetOrderBookResponse.decode(value),
  },
  getOhlcv: {
    path: "/ccxt.CcxtService/GetOHLCV",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetOHLCVRequest): Buffer =>
      Buffer.from(GetOHLCVRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetOHLCVRequest =>
      GetOHLCVRequest.decode(value),
    responseSerialize: (value: GetOHLCVResponse): Buffer =>
      Buffer.from(GetOHLCVResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetOHLCVResponse =>
      GetOHLCVResponse.decode(value),
  },
  getExchanges: {
    path: "/ccxt.CcxtService/GetExchanges",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetExchangesRequest): Buffer =>
      Buffer.from(GetExchangesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetExchangesRequest =>
      GetExchangesRequest.decode(value),
    responseSerialize: (value: GetExchangesResponse): Buffer =>
      Buffer.from(GetExchangesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetExchangesResponse =>
      GetExchangesResponse.decode(value),
  },
  getTickers: {
    path: "/ccxt.CcxtService/GetTickers",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetTickersRequest): Buffer =>
      Buffer.from(GetTickersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetTickersRequest =>
      GetTickersRequest.decode(value),
    responseSerialize: (value: GetTickersResponse): Buffer =>
      Buffer.from(GetTickersResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetTickersResponse =>
      GetTickersResponse.decode(value),
  },
  getTrades: {
    path: "/ccxt.CcxtService/GetTrades",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetTradesRequest): Buffer =>
      Buffer.from(GetTradesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetTradesRequest =>
      GetTradesRequest.decode(value),
    responseSerialize: (value: GetTradesResponse): Buffer =>
      Buffer.from(GetTradesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetTradesResponse =>
      GetTradesResponse.decode(value),
  },
  healthCheck: {
    path: "/ccxt.CcxtService/HealthCheck",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: HealthCheckRequest): Buffer =>
      Buffer.from(HealthCheckRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): HealthCheckRequest =>
      HealthCheckRequest.decode(value),
    responseSerialize: (value: HealthCheckResponse): Buffer =>
      Buffer.from(HealthCheckResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): HealthCheckResponse =>
      HealthCheckResponse.decode(value),
  },
} as const;

export interface CcxtServiceServer extends UntypedServiceImplementation {
  getTicker: handleUnaryCall<GetTickerRequest, GetTickerResponse>;
  getMarkets: handleUnaryCall<GetMarketsRequest, GetMarketsResponse>;
  getFundingRates: handleUnaryCall<
    GetFundingRatesRequest,
    GetFundingRatesResponse
  >;
  getOrderBook: handleUnaryCall<GetOrderBookRequest, GetOrderBookResponse>;
  getOhlcv: handleUnaryCall<GetOHLCVRequest, GetOHLCVResponse>;
  getExchanges: handleUnaryCall<GetExchangesRequest, GetExchangesResponse>;
  getTickers: handleUnaryCall<GetTickersRequest, GetTickersResponse>;
  getTrades: handleUnaryCall<GetTradesRequest, GetTradesResponse>;
  healthCheck: handleUnaryCall<HealthCheckRequest, HealthCheckResponse>;
}

export interface CcxtServiceClient extends Client {
  getTicker(
    request: GetTickerRequest,
    callback: (error: ServiceError | null, response: GetTickerResponse) => void,
  ): ClientUnaryCall;
  getTicker(
    request: GetTickerRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetTickerResponse) => void,
  ): ClientUnaryCall;
  getTicker(
    request: GetTickerRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetTickerResponse) => void,
  ): ClientUnaryCall;
  getMarkets(
    request: GetMarketsRequest,
    callback: (
      error: ServiceError | null,
      response: GetMarketsResponse,
    ) => void,
  ): ClientUnaryCall;
  getMarkets(
    request: GetMarketsRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: GetMarketsResponse,
    ) => void,
  ): ClientUnaryCall;
  getMarkets(
    request: GetMarketsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: GetMarketsResponse,
    ) => void,
  ): ClientUnaryCall;
  getFundingRates(
    request: GetFundingRatesRequest,
    callback: (
      error: ServiceError | null,
      response: GetFundingRatesResponse,
    ) => void,
  ): ClientUnaryCall;
  getFundingRates(
    request: GetFundingRatesRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: GetFundingRatesResponse,
    ) => void,
  ): ClientUnaryCall;
  getFundingRates(
    request: GetFundingRatesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: GetFundingRatesResponse,
    ) => void,
  ): ClientUnaryCall;
  getOrderBook(
    request: GetOrderBookRequest,
    callback: (
      error: ServiceError | null,
      response: GetOrderBookResponse,
    ) => void,
  ): ClientUnaryCall;
  getOrderBook(
    request: GetOrderBookRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: GetOrderBookResponse,
    ) => void,
  ): ClientUnaryCall;
  getOrderBook(
    request: GetOrderBookRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: GetOrderBookResponse,
    ) => void,
  ): ClientUnaryCall;
  getOhlcv(
    request: GetOHLCVRequest,
    callback: (error: ServiceError | null, response: GetOHLCVResponse) => void,
  ): ClientUnaryCall;
  getOhlcv(
    request: GetOHLCVRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetOHLCVResponse) => void,
  ): ClientUnaryCall;
  getOhlcv(
    request: GetOHLCVRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetOHLCVResponse) => void,
  ): ClientUnaryCall;
  getExchanges(
    request: GetExchangesRequest,
    callback: (
      error: ServiceError | null,
      response: GetExchangesResponse,
    ) => void,
  ): ClientUnaryCall;
  getExchanges(
    request: GetExchangesRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: GetExchangesResponse,
    ) => void,
  ): ClientUnaryCall;
  getExchanges(
    request: GetExchangesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: GetExchangesResponse,
    ) => void,
  ): ClientUnaryCall;
  getTickers(
    request: GetTickersRequest,
    callback: (
      error: ServiceError | null,
      response: GetTickersResponse,
    ) => void,
  ): ClientUnaryCall;
  getTickers(
    request: GetTickersRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: GetTickersResponse,
    ) => void,
  ): ClientUnaryCall;
  getTickers(
    request: GetTickersRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: GetTickersResponse,
    ) => void,
  ): ClientUnaryCall;
  getTrades(
    request: GetTradesRequest,
    callback: (error: ServiceError | null, response: GetTradesResponse) => void,
  ): ClientUnaryCall;
  getTrades(
    request: GetTradesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetTradesResponse) => void,
  ): ClientUnaryCall;
  getTrades(
    request: GetTradesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetTradesResponse) => void,
  ): ClientUnaryCall;
  healthCheck(
    request: HealthCheckRequest,
    callback: (
      error: ServiceError | null,
      response: HealthCheckResponse,
    ) => void,
  ): ClientUnaryCall;
  healthCheck(
    request: HealthCheckRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: HealthCheckResponse,
    ) => void,
  ): ClientUnaryCall;
  healthCheck(
    request: HealthCheckRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: HealthCheckResponse,
    ) => void,
  ): ClientUnaryCall;
}

export const CcxtServiceClient = makeGenericClientConstructor(
  CcxtServiceService,
  "ccxt.CcxtService",
) as unknown as {
  new (
    address: string,
    credentials: ChannelCredentials,
    options?: Partial<ClientOptions>,
  ): CcxtServiceClient;
  service: typeof CcxtServiceService;
  serviceName: string;
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
